\chapter{Data integrity}
\label{cha:DATAINT}\index{data integrity}
There is only one thing worse than losing the database. When the data is rubbish. In this chapter we'll
have a brief look to the constraints available in PostgreSQL and how they can be used to preserve the
data integrity..\newline

A constraint\index{constraint}, like the name suggest enforces one or more restrictions over the
table's data. When the restriction enforces the data on the relation where the constraint is defined,
then the constraint is local. When the constraints validates the local using the data in a different
relation then the constraint is foreign.\newline

The constraints can be defined like table or column constraint. The table constraints are defined at
table level, just after the field's list. A column constraint is defined in the field's definition after
the data type.\newline

When a constraint is created the enforcement applies immediately. At creation time the table's data is
validated against the constraint. If any validation error, then the creation aborts. However, the foreign
keys and the check constraints can be created without the initial validation using the clause NOT
VALID\index{constraint, NOT VALID}. This clause tells PostgreSQL to not validate the constraint's
enforcement on the existing data, improving the creation's speed.

\section{Primary keys} 
A primary key enforces the uniqueness of the participating fields. The uniqueness is enforced at
the strictest level because even the NULL values are not permitted. The primary key creates an implicit
unique index on the key's fields. Because the index creation requires the read lock this can cause
downtime. In \ref{sec:REINDEX} is explained a method which in some cases helps to minimise the
disruption. A table can have only one primary key.\newline

A primary key can be defined with the table or column constraint's syntax.

\begin{lstlisting}[style=pgsql]

--PRIMARY KEY AS TABLE CONSTRAINT
CREATE TABLE t_table_cons
        (
                i_id            serial,
                v_data          character varying (255),
                CONSTRAINT pk_t_table_cons PRIMARY KEY (i_id)
        )
;


--PRIMARY KEY AS COLUMN CONSTRAINT
CREATE TABLE t_column_cons
        (
                i_id            serial PRIMARY KEY,
                v_data          character varying (255)
        )
;
 

\end{lstlisting}

With the table constraint syntax it's possible to specify the constraint name.\newline

The previous example shows the most common primary key implementation. The constraint is defined over a
serial field. The serial\index{serial} type is a shortcut for \textbf{integer NOT NULL} with the default
value set by an auto generated sequence. The sequence's upper limit is 9,223,372,036,854,775,807.
However the integer's upper limit is just 2,147,483,647. On tables with a high generation for the key's
new values the bigserial\index{bigserial} should be used instead of serial. Changing the field's
type is still possible but unfortunately this requires a complete table's rewrite.\newline 


\begin{lstlisting}[style=pgsql]
postgres=# SET client_min_messages='debug5';
postgres=# ALTER TABLE t_table_cons ALTER COLUMN i_id SET DATA TYPE  bigint; 
DEBUG:  StartTransactionCommand
DEBUG:  StartTransaction
DEBUG:  name: unnamed; blockState:       DEFAULT; state: INPROGR, xid/subid/cid: 0/1/0, nestlvl: 1,
children: 
DEBUG:  ProcessUtility
DEBUG:  drop auto-cascades to index pk_t_table_cons
DEBUG:  rewriting table "t_table_cons"
DEBUG:  building index "pk_t_table_cons" on table "t_table_cons"
DEBUG:  drop auto-cascades to type pg_temp_51718
DEBUG:  drop auto-cascades to type pg_temp_51718[]
DEBUG:  CommitTransactionCommand
DEBUG:  CommitTransaction
DEBUG:  name: unnamed; blockState:       STARTED; state: INPROGR, xid/subid/cid: 9642/1/14, nestlvl: 1,
children: 
ALTER TABLE


\end{lstlisting}

The primary keys can be configured as natural keys, with the field's values meaningful in the real
world. For example a table storing the cities will have the field v\_city as primary key instead of
the surrogate key i\_city\_id.                                                                          
        

\begin{lstlisting}[style=pgsql]
--PRIMARY NATURAL KEY 
CREATE TABLE t_cities
        (
                v_city          character varying (255),
                CONSTRAINT pk_t_cities PRIMARY KEY (v_city)
        )
;
\end{lstlisting}

This results in a more compact table with the key values already indexed.


\section{Unique keys}
The unique keys are very similar to the primary keys. They enforce the uniqueness using an implicit 
index but the NULL values are permitted. Actually a primary key is the combination of a unique key
and the NOT NULL constraint. The unique keys are useful when the uniqueness should be enforced on
fields not participating to the primary key. 
\newpage

\section{Foreign keys}
\label{sec:FKEYS}
A foreign key is a constraint which ensures the data is compatible with the values stored in a foreign
table's field. The typical example is when two tables need to enforce a relationship. For example let's
consider a table storing the addresses.

\begin{lstlisting}[style=pgsql]
CREATE TABLE t_addresses
        (
                i_id_address    serial,
                v_address       character varying(255),
                v_city          character varying(255),
                CONSTRAINT pk_t_addresses PRIMARY KEY (i_id_address)
        )
;
\end{lstlisting}

Being the city a value which can be the same for many addresses is more efficient to store the city name
into a separate table and set a relation to the address table.

\begin{lstlisting}[style=pgsql]
CREATE TABLE t_addresses
        (
                i_id_address    serial,
                v_address       character varying(255),
                i_id_city       integer NOT NULL,
                CONSTRAINT pk_t_addresses PRIMARY KEY (i_id_address)
        )
;

CREATE TABLE t_cities
        (
                i_id_city    serial,
                v_city       character varying(255),
                CONSTRAINT pk_t_cities PRIMARY KEY (i_id_city)
        )
;

\end{lstlisting}

The main problem with this structure is the consistency between the tables. Without constraints
there is no validation for the city identifier. Invalid values will make the table's join invalid. The
same will happen if for any reason the city identifier in the table t\_cities is changed.\newline

Enforcing the relation with a foreign key will solve both of the problems.

\begin{lstlisting}[style=pgsql]
ALTER TABLE t_addresses 
  ADD CONSTRAINT fk_t_addr_to_t_city
  FOREIGN KEY (i_id_city)
  REFERENCES t_cities(i_id_city)
  ;

\end{lstlisting}

The key works in two ways. When a row with an invalid i\_id\_city hits the table t\_addresses 
the key is violated and the insert aborts. Deleting or updating a row from the table t\_cities referenced
in the table t\_addresses, violates the key.\newline

The enforcement is performed with the triggers. When performing a data only dump or restore, the option
--disable-trigger is compulsory to complete successfully the data restore.More information about the
backup and restore are in \ref{cha:BACKUP}, \ref{cha:RESTORE}.\newline

The FOREIGN KEYS have many options giving a great configuration's flexibility. 
The referenced table can drive actions on the referencing using the two options ON DELETE and ON 
UPDATE. By default the behaviour is to take NO ACTION if there are referencing rows until the 
end of the transaction. This is useful if the key check should be deferred to the end of the 
transaction. The other two actions are the RESTRICT which does not allow the deferring and 
the CASCADE which cascade the action to the referred rows. 

If we want our foreign key restrict the delete with no deferring and cascade any update, here's the 
DDL.

\begin{lstlisting}[style=pgsql]
ALTER TABLE t_addresses 
  ADD CONSTRAINT fk_t_addr_to_t_city
  FOREIGN KEY (i_id_city)
  REFERENCES t_cities(i_id_city)
  ON UPDATE CASCADE ON DELETE RESTRICT
  ;

\end{lstlisting}

Another very useful clause available with the foreign and check constraints is the NOT VALID. When 
the constraint is created with NOT VALID, the initial check is skipped making the constraint 
creation instantaneous. This is acceptable if the actual data is consistent. The constraint is then 
enforced for all the new data. The invalid constraint can be validated later with the command 
VALIDATE CONSTRAINT.

\begin{lstlisting}[style=pgsql]
postgres=#ALTER TABLE t_addresses
                ADD CONSTRAINT fk_t_addr_to_t_city
                FOREIGN KEY (i_id_city)
                REFERENCES t_cities(i_id_city)
                ON UPDATE CASCADE ON DELETE RESTRICT
                NOT VALID
                ;
ALTER TABLE
postgres=# ALTER TABLE t_addresses VALIDATE CONSTRAINT fk_t_addr_to_t_city ;
ALTER TABLE

\end{lstlisting}



\section{Check constraints}
\label{sec:CHECKCNS}

A check constraint is a user defined check to enforce specific condtions on the rows. 
The definition can be a condition or a used defined function. In this case the function must return 
a boolean value.  As for the foreign keys, the check accepts the NOT VALID clause to speed up the 
creation.\newline

The check is satisfied if the condition returns true or NULL. This behaviour can 
produce unpredictable results if not fully understood. An example will help to clarify. 
Let's create a CHECK constraint on the v\_address table for enforcing a the presence of a value.
Even with the check in place the insert without the address completes successfully.

\begin{lstlisting}[style=pgsql]
postgres=# ALTER TABLE t_addresses
                ADD CONSTRAINT chk_t_addr_city_exists
                CHECK (length(v_address)>0)
                ; 
postgres=# INSERT INTO t_cities (v_city) VALUES ('Brighton') RETURNING i_id_city;
 i_id_city 
-----------
         2

postgres=# INSERT INTO t_addresses (i_id_city) VALUES (2);
INSERT 0 1
\end{lstlisting}


This is possible because the v\_address does not have a default value and accepts the NULL 
values. The check constraint is violated if, for example we'll try to update the v\_address with 
the empty string.

\begin{lstlisting}[style=pgsql]
postgres=# UPDATE t_addresses SET v_address ='' ;
ERROR:  new row for relation "t_addresses" violates check constraint "chk_t_addr_city_exists"
DETAIL:  Failing row contains (3, , 2)
\end{lstlisting}

Our check constraint will work as expected if we set for the v\_address field a fallback default 
value.

\begin{lstlisting}[style=pgsql]
postgres=# ALTER TABLE t_addresses ALTER COLUMN v_address SET DEFAULT '';
ALTER TABLE
postgres=# INSERT INTO t_addresses (i_id_city) VALUES (2);
ERROR:  new row for relation "t_addresses" violates check constraint "chk_t_addr_city_exists"
DETAIL:  Failing row contains (4, , 2).

\end{lstlisting}
Please note the existing rows are not affected by the default value change.

The message for the update and the insert is exactly the same because PostgreSQL attempts to create 
a new row in both cases. When the constraint fails the transaction is rolled back leaving the dead 
row in place. We'll take a better look to the MVCC in \ref{sec:MVCC}.


\section{Not null}
For people approaching the database universe the NULL value can be quite confusing. A NULL value is 
an empty object without any type or meaning. Actually when a field is NULL it doesn't consumes 
physical space. By default when defining a field this is NULLable. Those fields are quite useful to 
omit some columns, for example, at insert time.\newline
The NULLable fields can be enforced with an unique constraint as the NULL are not considered as 
duplicates. When dealing with the NULL it's important to remind the NULL acts like the mathematical 
zero. When evaluating an expression with a NULL, the entire expression becomes NULL.\newline

The NOT NULL is a column constraint which forbids the presence of NULL in the affected field. 
Combining a NOT NULL with a unique constraint is exactly like having enforced a PRIMARY KEY. When 
altering a field the table is scanned for validation and the constraint's creation is aborted if 
any NULL value is present on the affected field.\newline

For example, if we want to add the NOT NULL constraint to the field v\_address in the t\_addresses 
table the command is just.

\begin{lstlisting}[style=pgsql]
postgres=# ALTER TABLE t_addresses ALTER COLUMN v_address SET NOT NULL;
ERROR:  column "v_address" contains null values

\end{lstlisting}

In this case the alter fails because the column v\_address contains NULL values from the example 
seen in \ref{sec:CHECKCNS}. The fix can be performed in a single query using the coalesce function.
This function returns the first not null value from the left. This way is possible to change the 
v\_address on the fly to a fixed placeholder \footnote{we've set the check constraint to avoid empty 
addresses}.

\begin{lstlisting}[style=pgsql]
postgres=# UPDATE t_addresses
            SET v_address='EMPTY'
            WHERE v_address IS NULL;
UPDATE 1
postgres=# ALTER TABLE t_addresses ALTER COLUMN v_address SET NOT NULL;
ALTER TABLE

\end{lstlisting}

Adding new columns with NULL is quick. PostgreSQL simply adds the new attribute in the system 
catalogue and manages the new tuple structure considering the new field as empty space. Adding 
a field with NOT NULL requires the presence of the DEFAULT value as well. This is an operation to 
consider carefully when dealing with big amount of data. This way the table will be locked in 
exclusive mode and a complete relation's rewrite will happen. A far better way is to add a NOT NULL 
field is to add at first as NULLable field. A second alter will add the default value to have the 
new rows correctly set. An update will then fix the NULL values without locking the 
table. Finally the NOT NULL could be enforced without hassle.