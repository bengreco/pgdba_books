\chapter{Maintenance}
\label{cha:MAINTENANCE}\index{Maintenance}
The database maintenance is something crucial for the efficiency of the data access, the integrity 
and the reliability. Any database sooner or later will need a proper maintenance plan. \newline

When a new tuple's version is generated by an update it can be put everywhere there's free space. 
Frequent updates can result in tuples moving across the data pages many and many times leaving a 
trail of dead tuples behind them. Because the dead tuples are physically stored but no 
longer visible this creates an extra overhead causing the table to bloat.
Indices makes things more complicated because when a tuple changes page the index entry is updated 
to point the new page and because of the index's ordered structure, the bloating is more 
probable than the table. 


\section{vacuum}\index{VACUUM}
\label{sec:VACUUM}
VACUUM is a PostgreSQL specific command which reclaims back the dead tuple's space. When called 
without specifying a target table, the command processes all the tables in the database. Running 
regulary VACUUM have some beneficial effects.

\begin{itemize}
 \item It reclaims back the dead tuple's disk space.
 \item It updates the visibility map making the index scans run faster.
 \item It freezes the tuples with old XID protecting from the XID wraparound\index{XID wraparound} 
data loss
\end{itemize}

The optional ANALYZE clause also gather the statistics on processed table, more details here 
\ref{sec:ANALYZE}.\newline

A standard VACUUM's run, frees the space used by the dead rows inside the data files but doesn't 
returns the space to the operating system. VACUUM doesn't affects the common database activity 
but prevents any schema change on the processed table. Because the pages are rewritten, a VACUUM 
run increases substantially the I/O activity. \newline

The presence of one or more empty pages in the table's end can be removed by VACUUM if an 
exclusive lock on the relation can be obtained immediately. When this happens the table is scanned 
backward to find all the empty pages and then it's truncated to the first not empty page. The index 
pages are scanned as well and the dead tuples are also cleared. The VACUUM's truncate scan works 
only on the heap data files. VACUUM'S performances are influenced by the maintenance\_work\_mem 
only if the table have indices, otherwise the VACUUM will run the cleanup sequentially without 
storing the tuple's references for the index cleanup.\newline

To show the effect of the maintenance\_work\_mem  let's build build a simple table with 10 
million rows. 


\begin{lstlisting}[style=pgsql]
postgres=# CREATE TABLE t_vacuum 
        (
                i_id serial,
                t_ts_value timestamp with time zone DEFAULT clock_timestamp(),
                t_value text,
                CONSTRAINT pk_t_vacuum PRIMARY KEY  (i_id)
        )
;
CREATE TABLE

postgres=# INSERT INTO t_vacuum
        (t_value)
SELECT 
         md5(i_cnt::text)
FROM
(
        SELECT
                generate_series(1,10000000) as i_cnt
) t_cnt
;
INSERT 0 10000000


\end{lstlisting}
To have a statical environment we'll disable the table's autovacuum. More infos on autovacuum here 
\ref{sec:AUTOVACUUM}.
We'll also increase the session's verbosity to look out what's happening during the VACUUM's 
 run.\newline
\begin{lstlisting}[style=pgsql]
postgres=# ALTER TABLE t_vacuum 
        SET 
                (
                        autovacuum_enabled = false, 
                        toast.autovacuum_enabled = false
                )
;
ALTER TABLE


SET client_min_messages='debug';

\end{lstlisting}

We are now executing a complete table rewrite running an UPDATE without the WHERE condition. 
This will create 10 millions of dead rows.\newline

\begin{lstlisting}[style=pgsql]
postgres=# UPDATE t_vacuum 
        SET 
                t_value = md5(clock_timestamp()::text)
;
UPDATE 10000000

\end{lstlisting}

Before running the VACUUM we'll change the maintenance\_work\_mem to a small value enabling the the 
timing to check the query duration.\newline

\begin{lstlisting}[style=pgsql]
postgres=# SET maintenance_work_mem ='20MB';
SET
postgres=# \timing
Timing is on.

postgres=# VACUUM t_vacuum;
DEBUG:  vacuuming "public.t_vacuum"
DEBUG:  scanned index "pk_t_vacuum" to remove 3495007 row versions
DETAIL:  CPU 0.80s/4.56u sec elapsed 21.36 sec.
DEBUG:  "t_vacuum": removed 3495007 row versions in 36031 pages
DETAIL:  CPU 0.63s/0.56u sec elapsed 19.31 sec.
DEBUG:  scanned index "pk_t_vacuum" to remove 3495007 row versions
DETAIL:  CPU 0.67s/4.18u sec elapsed 15.28 sec.
DEBUG:  "t_vacuum": removed 3495007 row versions in 36031 pages
DETAIL:  CPU 0.67s/0.53u sec elapsed 18.07 sec.
DEBUG:  scanned index "pk_t_vacuum" to remove 3009986 row versions
DETAIL:  CPU 0.53s/2.86u sec elapsed 12.29 sec.
DEBUG:  "t_vacuum": removed 3009986 row versions in 31031 pages
DETAIL:  CPU 0.47s/0.52u sec elapsed 20.06 sec.
DEBUG:  index "pk_t_vacuum" now contains 10000000 row versions in 82352 pages
DETAIL:  10000000 index row versions were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
DEBUG:  "t_vacuum": found 10000000 removable, 10000000 nonremovable row versions in 206186 out of 
206186 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 5.92s/17.08u sec elapsed 154.10 sec.
DEBUG:  vacuuming "pg_toast.pg_toast_28499"
DEBUG:  index "pg_toast_28499_index" now contains 0 row versions in 1 pages
DETAIL:  0 index row versions were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
DEBUG:  "pg_toast_28499": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
VACUUM
Time: 154143.383 ms
postgres=# 


\end{lstlisting}

During the VACUUM the the maintenance\_work\_mem is used to store an array of TCID referencing 
the dead tuples for the index cleanup. If the maintenance\_work\_mem is small and the dead rows are 
many, the memory fills up often. When this happens the table scan pauses and the index is 
scanned searching for the tuples stored into the array. When the index scan is complete the array of 
TCID is emptied and the table's scan resumes. Increasing the maintenance\_work\_mem to 2 
GB\footnote{In order to have the table in the same conditions, a VACUUM FULL and a new update has 
been runt before the conventional VACUUM.} the index scan is executed in one single run 
resulting in a VACUUM 32 seconds faster.\newline

\begin{lstlisting}[style=pgsql]
postgres=# SET maintenance_work_mem ='2GB';
SET

postgres=# VACUUM t_vacuum;
DEBUG:  vacuuming "public.t_vacuum"
DEBUG:  scanned index "pk_t_vacuum" to remove 10000000 row versions
DETAIL:  CPU 1.58s/8.45u sec elapsed 52.41 sec.
DEBUG:  "t_vacuum": removed 10000000 row versions in 103093 pages
DETAIL:  CPU 1.78s/1.41u sec elapsed 33.90 sec.
DEBUG:  index "pk_t_vacuum" now contains 10000000 row versions in 82352 pages
DETAIL:  10000000 index row versions were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
DEBUG:  "t_vacuum": found 10000000 removable, 10000000 nonremovable row versions in 206186 out of 
206186 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 5.62s/13.64u sec elapsed 121.99 sec.
DEBUG:  vacuuming "pg_toast.pg_toast_28499"
DEBUG:  index "pg_toast_28499_index" now contains 0 row versions in 1 pages
DETAIL:  0 index row versions were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
DEBUG:  "pg_toast_28499": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
VACUUM
Time: 122021.251 ms


\end{lstlisting}

A table without indices does use the maintenance\_work\_mem. For example if we run 
the VACUUM after dropping the table's primary key the execution is faster even with the low 
maintenance\_work\_mem setting.\newline

\begin{lstlisting}[style=pgsql]

postgres=# SET maintenance_work_mem ='20MB';
SET
postgres=# \timing
Timing is on.

postgres=# ALTER TABLE t_vacuum DROP CONSTRAINT pk_t_vacuum;
DEBUG:  drop auto-cascades to index pk_t_vacuum
ALTER TABLE
Time: 182.737 ms

postgres=# VACUUM t_vacuum;
DEBUG:  vacuuming "public.t_vacuum"
DEBUG:  "t_vacuum": removed 10000000 row versions in 103093 pages
DEBUG:  "t_vacuum": found 10000000 removable, 10000000 nonremovable row versions in 206186 out of 
206186 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 2.16s/4.53u sec elapsed 47.30 sec.
DEBUG:  vacuuming "pg_toast.pg_toast_28499"
DEBUG:  index "pg_toast_28499_index" now contains 0 row versions in 1 pages
DETAIL:  0 index row versions were removed.
0 index pages have been deleted, 0 are currently reusable.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
DEBUG:  "pg_toast_28499": found 0 removable, 0 nonremovable row versions in 0 out of 0 pages
DETAIL:  0 dead row versions cannot be removed yet.
There were 0 unused item pointers.
0 pages are entirely empty.
CPU 0.00s/0.00u sec elapsed 0.00 sec.
VACUUM
Time: 48823.132 ms




\end{lstlisting}

The table seen in the example begins with a size of 806 MB . After the update the table double its 
size which remains the same during the VACUUM runs the updates. This happens because after the 
first insert the table had all the rows packed together; the update added in the table's bottom the 
new row versions leaving the previous 10 millions row on the table's top as dead tuples. The 
VACUUM's run cleared the space on the table's top but weren't able to truncate because all 
the rows packed in the table's bottom. Running a new UPDATE followed by VACUUM would free the space 
in the table's bottom and a truncate scan would succeed but only if there's no tuple in the table's 
end free space. To check if the vacuum is running effectively the tables should show an initial 
growt followed by a substantial size stability in time. This happens only if the new rows are 
versioned at the same rate of the old rows clear down.\newline

The XID wraparound failure protection is performed automatically by VACUUM which when it finds a 
live tuple with a t\_xmin's age bigger than the GUC parameter vacuum\_freeze\_min\_age, then it 
replaces the tuple's creation XID with the FrozenXID preserving the tuple's visibility forever. 
Because VACUUM by default skips the pages without dead tuples it will miss some aging tuples. 
That's the reason why it's present a second GUC parameter, vacuum\_freeze\_table\_age, which 
triggers a VACUUM's full table scan when the table's relfrozenxid age exceeds the value.\newline

VACUUM accepts the FREEZE \index{VACUUM FREEZE} clause which forces a complete tuple freeze 
regardless to the age. That's equivalent to run the VACUUM setting the vacuum\_freeze\_min\_age to 
zero.


\section{analyze}
\label{sec:ANALYZE}


\section{reindex}
\begin{comment}
  . A B-tree index is a tree of 
table's implementation, An index is The tuples moving across the data files is the index entries 
shall be updated. A B-tree index entry basically carries the indexed value with the pointer to the 
page containing the tuple. When the tupe change page the index entry shall be updated. This require 
\end{comment}

\section{VACUUM FULL and CLUSTER}


\section{The autovacuum daemon}
\label{sec:AUTOVACUUM}