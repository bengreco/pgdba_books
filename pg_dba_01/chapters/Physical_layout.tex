\chapter{The physical layout}
\label{cha:PHYLAY}\index{Physical layout}
After looking to the logical structure we'll now dig into PostgreSQL's physical structure. 
We'll start with the top layer, looking into the data area. We'll take a look first to the 
data files and how they are organised. Then we'll move inside them, where the data pages 
and the fundamental storage unit, the tuples, are stored. A section is dedicated to the 
TOAST tables. The chapter will end with the physical aspect of the tablespaces and the 
MVCC\index{MVCC}.

\section{Data files}\index{Data files}
As seen in \ref{sec:PGDATA} the data files are stored into the \$PGDATA/base directory, 
organised per database object identifier. This is true also for the relations created 
on a different tablespace. Inside the database directories there are many files which 
name is numeric as well. When a new relation is created, the name is set initially to the 
relation's object identifier. The relation's file name can change if any actiont like 
REINDEX or VACUUM FULL is performed on the relation.\newline

The data files are organised in multiple segments, each one of 1 GB and numbered with a 
suffix. However the first segment created is without suffix. Alongside the main data 
files there are some additional forks needed used by PostgreSQL for tracking the data 
visibility and free space.

\subsection{Free space map}\index{Free space map}
The free space map is a segment present alongside the index\index{Index, files} and 
table's data files . It have the same the relation's name with the suffix \_fsm. 
PostgreSQL stores the information of the free space available. 

\subsection{Visibility map}\index{Visibility map}
The table's data file have a visibility map file which suffix is \_vm. PostgreSQL 
tracks the data pages with all the tuples visible to the active transactions. This fork 
is also used for running the index only scans\index{index only scans}.

\subsection{Initialisation fork}\index{Initialisation fork}
The initialisation fork is an empty file used to re initialise the unlogged relations 
when the cluster performs a crash recovery.

\subsection{pg\_class}
When connecting to a database, all the relations inside it are listed in the 
pg\_class\index{pg\_class} system table. The field relfilenode stores the relation's 
filename. The system field oid, which is hidden when selecting with the wildcard *, is 
just the relation's object identifier and should not be used for the physical 
mapping.\newline

However, PostgreSQL have many useful functions which retrieve the information 
using the relation's OID. For example the function pg\_total\_relation\_size(regclass) 
returns the disk space used by the table, including the additional forks and the eventual 
TOAST table, andthe indices. The function returns the size in bytes. Another function, 
the pg\_size\_pretty(bigint), returns a human readable format for better reading.\newline

The pg\_class's field relkind is used to store the relation's kind.

\begin{table}[h]
  \begin{tabular}{cc}
    Value & Relation's kind\\
    \hline
    r  &  ordinary table \\
    i  &  index \\
    S  &  sequence \\
    v  &  view \\
    m  &  materialised view \\
    c  &  composite type \\
    t  &  TOAST table \\
    f  &  foreign table \\
    
  \end{tabular}
  \caption{\label{tab:RELKIND}Relkind values}
\end{table}

\section{Pages}\index{Data pages}
Each datafile is a collection of elements called pages. The default size is for a data 
page is 8 kb. The page size can be changed only recompiling the sources with the 
different configuration and re initialising the data area. Table's pages are also 
known as heap pages\index{Heap pages}. The index pages\index{Index pages} have almost the 
same heap structure except for the special space allocated in the page's bottom. The 
figure \ref{fig:INDEX01} shows an index page structure. The special  space is used 
to store information needed by the relation's structure. For example a B-tree index 
puts in the special space the pointers to the pages below in the B-tree structure.

\begin{figure}[H]
\begin{center}

\includegraphics[scale=0.35]{images/index_page_01.png}

\caption{Index page}
\label{fig:INDEX01} 
\end{center}

\end{figure}

A data page starts with a header of \index{Data pages,header}24 bytes. After the 
header there are the item pointers, which size is usually 4 bytes. Each item 
pointer\index{Item pointers} is an array of pairs composed by the offset and the length 
of the item which ponints the physical tuples in the page's bottom.\newline 

The page header holds the information for the page's generic space management as shown 
in figure \ref{fig:HEADERPAG01}. 


\begin{figure}[H]
\begin{center}

\includegraphics[scale=0.55]{images/header_page_01.png}

\caption{Page header}
\label{fig:HEADERPAG01} 
\end{center}

\end{figure}
\begin{itemize}
 \item \textbf{pd\_lsn} identifies the xlog record for last page's change.  The 
buffer manager uses the  LSN for enforcing the WAL mechanism. A dirty buffer is not 
dumped to the disk until the xlog has been flushed at least as far as the page's LSN.
\item \textbf{pd\_checksum} stores the page's checksum if is enabled.
\item \textbf{pd\_flags} is used to store the page's various flags 
\item \textbf{pg\_lower} is the offset to the start of the free space
\item \textbf{pg\_upper} is the offset to the end of the free space
\item \textbf{pg\_special} is the offset to the start of the special space
\item \textbf{pd\_pagesize\_version} is the page size and the page version packed 
together in a single field. 
\item \textbf{pg\_prune\_xid} is a hint field to determine if the tuple's pruning is 
useful. Is set only on the heap pages.

\end{itemize}

The pd\_checksum \index{Page checksum}field replaces the pd\_tli field present in the page 
header until PostgreSQL 9.2 which was used to track the xlog records across the timeline id. 
\newline 

The page's checksum is a new 9.3's feature which can detects the page corruption. It can be enabled only 
when the data area is initialised with initdb.\newline

The offset fields, pg\_lower, pd\_upper and the optional pd\_special, are 2 bytes long limiting the 
max page size to 32KB.\newline

The field for the page version\index{Page version} was introduced with PostgreSQL 7.3. 
Table \ref{tab:PGPAGEVERSION} shows the page version number for the major versions.

\begin{table}[h]
  \begin{tabular}{cc}
    PostgreSQL version & Page version\\
    \hline
    \textgreater \space 8.3  &  4\\
    8.1,8.2  &  3\\
    8.0  &  2\\
    7.4,7.3  &  1\\
    \textless \space 7.3  &  0\\
    
    
  \end{tabular}
  \caption{\label{tab:PGPAGEVERSION}PostgreSQL page version}
\end{table}

\section{Tuples}\index{Tuples}
\label{sec:TUPLES}
The tuples are the fundamental storage unit in PostgreSQL. They are organised as array of items which kind 
is initially unknown, the datum. Each tuple have a fixed header of 23 bytes as shown in the figure 
\ref{fig:TUPLES01}.\newline

\begin{figure}[H]
\begin{center}

\includegraphics[scale=0.55]{images/tuples_01.png}

\caption{Tuple structure}
\label{fig:TUPLES01} 
\end{center}

\end{figure}

The fields t\_xmin\index{t\_xmin} and t\_xmax\index{t\_xmax} are used to track the tuple's visibility as 
seen in \ref{sec:MVCC}. The field t\_cid\index{t\_cid} is a ``virtual'' field and is used either for cmin 
and cmax. \newline

The field t\_xvac\index{t\_xvac} is used by VACUUM when moving the rows, according with the source code's 
comments in src/include/access/htup\_details.h this field is used only by the old style VACUUM FULL. 
\newline

The field t\_cid\index{t\_cid} is the tuple's physical location identifier. Is composed by a couple of 
integers representing the page number and the tuple's index along the page. When a new tuple is created 
t\_cid is set to the actual row's value. When the tuple is updated the this 
value changes to the new tuple's version location. This field is used in pair with t\_xmax to check if 
the tuple is the last version. The two infomask fields are used to store various flags like the presence of 
the tuple's OID or if the tuple have NULL values. The last field t\_off is used to set the offset to the 
actual tuple's data. This field's value is usually zero if the table doesn't have NULLable fields or is 
created WITHOUT OIDS. If the tuples have the OID and or a NULLable fields, the object identifier and 
a NULL bitmap are stored immediately after the tuple's header. The bitmap if present begins just after the 
tuple's header and consumes enough bytes to have one bit per data column. The OID if present is stored 
after the bitmap and consumes 4 bytes. The tuple's data is a stream of composite data described by the 
composite model stored in the system catalogue. 


\section{TOAST}\index{TOAST}
\label{sec:TOAST}
The oversize attribute storage technique is the PostgreSQL implementation for storing the data 
which overflows the page size. PostgreSQL does not allow the tuples spanning multiple pages. However is 
possible to store large amount of data which is compressed or split in multiple rows in an external 
TOAST table. The mechanism is completely transparent from the user's point of view.\newline

The storage model treats the fixed length, like the integers, and the variable length types, like text, in 
a different way. The fixed length types which cannot produce large data are not processed through the TOAST 
routines. The variable length types are TOASTable if the first 32-bit word of any stored value contains the 
total length of the value in bytes (including itself).

The kind of the TOAST is stored in the first two bits\footnote{On the big-endian architecture those are the 
high-order bits; on the little-endian those are the low-order bits} of the varlena\index{varlena} length 
word. When both bits are zero then the attribute is an unTOASTed data type. In the remaining bits is stored 
the datum size in bytes including the length word.\newline

If the first bit is set then the value have only a single-byte header instead of the four byte header. 
In the remaining bits is stored the total datum size in bytes including the length byte. This scenario 
have a special case uf the remaining bits are all zero. This means the value is a pointer to an out of line 
data stored in a separate TOAST table which structure is shown in figure \ref{fig:TOAST01}.\newline

Finally, whether is the first bit,  if the second bit is set then the corresponding datum is compressed and 
must be decompressed before the use.\newline

Because the TOAST usurps the first two bits of the varlena length word it limits the max stored size to 1 
GB  \begin{math} (2^{30} -1 bytes) \end{math} .

\begin{figure}[H]
\begin{center}

\includegraphics[scale=0.55]{images/toast_01.png}

\caption{Toast table structure}
\label{fig:TOAST01} 
\end{center}

\end{figure}

The toast table is composed by three fields. The chunk\_id is an OID used to store the chunk identifiers. 
The chunk\_seq is an integer which stores the chunk orders. The chunk\_data is a bytea field containing the 
the actual data converted in a binary string.\newline 

The chunk size is normally 2k and is controlled at compile time by the symbol TOAST\_MAX\_CHUNK\_SIZE. The 
TOAST code is triggered by the value TOAST\_TUPLE\_THRESHOLD, also 2k by default. When the tuple's size is 
bigger than TOAST\_TUPLE\_THRESHOLD then the TOAST routines are triggered.\newline

The TOAST\_TUPLE\_TARGET, default 2 kB, governs the compression's behaviour. PostgreSQL will compress the 
datum to achieve a final size lesser than TOAST\_TUPLE\_TARGET. Otherwise the out of line storage is used.

TOAST offers four different storage strategies. Each strategy can be changed per column using the  ALTER 
TABLE SET STORAGE statement.
\begin{itemize}

\index{TOAST, storage strategies}
\item  PLAIN prevents either compression or out-of-line storage; It's the only storage available 
for fixed length data types.

\item  EXTENDED allows both compression and out-of-line storage. It is the default for most 
TOAST-able data types. Compression will be attempted first, then out-of-line storage if the row is 
still too big.

\item  EXTERNAL allows out-of-line storage but not compression. 

\item  MAIN allows compression but not out-of-line storage. Actually the out-of-line storage is 
still performed as last resort.

\end{itemize}

The out of line storage\index{TOAST, out of line storage} have the advantage of leaving out the 
stored data from the row versioning; if the TOAST data is not affected by the update there will be 
no dead row for the TOAST data. That's possible because the varlena is a mere pointer to the chunks 
and a new row version will affect only the pointer leaving the TOAST data unchanged.\newline
The TOAST table are stored like all the other relation's in the pg\_class table, the associated 
table can be found using a self join on the field reltoastrelid.\newline


\section{Tablespaces}\index{tablespaces,physical}
\label{sub:TBS-PHYSICAL}
PostgreSQL implements the tablespaces creating the symbolic links, pointing the tablespace's 
location, into the pg\_tblspc. The links are named like the tablespace's OID. The tablespaces are 
available only on systems supporting the symbolic links.\newline

Since PostgreSQL 9.1 the tablespace location was stored into the field spclocation of the 
pg\_tablespace\index{pg\_tablespace} system table. The information was used only to dump the 
tablespace's definition during a pg\_dump and was removed in the version 9.2 and it was was 
introduced the function pg\_tablespace\_location(tablespace\_oid) to get the tablespace's absolute 
path from the tablespace oid.\newline

Querying the system catalogue to acquire any sort of informations is quite  simple. In this example 
the query returns the tablespace's location seen in \ref{sub:TBS-LOGICAL} 

\begin{lstlisting}[style=pgsql]
 postgres=# 
 SELECT 
        pg_tablespace_location(oid),
        spcname 
FROM 
        pg_tablespace;
       pg_tablespace_location       |  spcname   
------------------------------------+------------
                                    | pg_default
                                    | pg_global
 /var/lib/postgresql/pg_tbs/ts_test | ts_test
(3 rows)

\end{lstlisting}

The function returns the empty string for the system tablespaces, pg\_default and pg\_global, 
because those locations have an immutable location, relative to the data directory. We can get the 
data area's absolute path using the function current\_settings. 

\begin{lstlisting}[style=pgsql]
 postgres=# SELECT current_setting('data_directory');
       current_setting        
------------------------------
 /var/lib/postgresql/9.3/main
(1 row)

\end{lstlisting}

Using the CASE construct is then possible to build up an more complete query to lookout at the 
tablespaces locations.\newpage

\begin{lstlisting}[style=pgsql]
 postgres=# 
SELECT 
        CASE
                WHEN 
                                pg_tablespace_location(oid)=''
                        AND     spcname='pg_default'
                THEN
                        current_setting('data_directory')||'/base/'
                WHEN 
                                pg_tablespace_location(oid)=''
                        AND     spcname='pg_global'
                THEN
                        current_setting('data_directory')||'/global/'
        ELSE
                pg_tablespace_location(oid)
        END
        AS      spclocation,
                
        spcname 
FROM 
        pg_tablespace;
             spclocation              |  spcname   
--------------------------------------+------------
 /var/lib/postgresql/9.3/main/base/   | pg_default
 /var/lib/postgresql/9.3/main/global/ | pg_global
 /var/lib/postgresql/pg_tbs/ts_test   | ts_test
(3 rows)

\end{lstlisting}

Before the version 8.4 the tablespace location pointed directly to the referenced directory, 
causing 
a potential location's clash. The newer versions introduced the usage of a container directory into 
the tablespace location named after the major version and the system catalogue version number. 
\newline

\begin{verbatim}

postgres@tardis:~$ ls -l /var/lib/postgresql/pg_tbs/ts_test
total 0
drwx------ 2 postgres postgres 6 Jun  9 13:01 PG_9.3_201306121

\end{verbatim}

The tablespace's directory container is structured this way\newline
PG\_\{MAJOR\_VERSION\}\_\{CATALOGUE\_VERSION\_NUMBER\}\newline

The major version is the PostgreSQL version truncated to the second cypher and the catalogue's 
version number is the same shown in the pg\_controldata output, a formatted date.

\begin{verbatim}
postgres@tardis:~$ export PGDATA=/var/lib/postgresql/9.3/main
postgres@tardis:~$ /usr/lib/postgresql/9.3/bin/pg_controldata 
pg_control version number:            937
Catalog version number:               201306121
Database system identifier:           5992975355079285751
Database cluster state:               in production
pg_control last modified:             Mon 09 Jun 2014 13:05:14 UTC
.
.
.
WAL block size:                       8192
Bytes per WAL segment:                16777216
Maximum length of identifiers:        64
Maximum columns in an index:          32
Maximum size of a TOAST chunk:        1996
Date/time type storage:               64-bit integers
Float4 argument passing:              by value
Float8 argument passing:              by value
Data page checksum version:           0

\end{verbatim}

Inside the container directory the structure is same as the directory base seen in 
\ref{sec:PGDATA}, 
with one difference. There're only the subdirectories for the databases having relations on the 
tablespace.\newline

To get all the databases with objects on the current tablespace it's present the function 
pg\_tablespace\_databases(tablespace\_oid) which returns the set of the database OID with objects 
on 
the specified tablespace. In order to have a better picture we can join the query with the 
pg\_database system table.\newline

Here's an example query using the CASE construct with the pg\_tablespace\_databases function, to 
get 
all the databases with objects on the ts\_test tablespace.\newpage
\begin{lstlisting}[style=pgsql]
 db_test=# 
 SELECT
        datname,
        spcname,
        CASE
                WHEN 
                                pg_tablespace_location(tbsoid)=''
                        AND     spcname='pg_default'
                THEN
                        current_setting('data_directory')||'/base/'
                WHEN 
                                pg_tablespace_location(tbsoid)=''
                        AND     spcname='pg_global'
                THEN
                        current_setting('data_directory')||'/global/'
        ELSE
                pg_tablespace_location(tbsoid)
        END
        AS      spclocation
FROM
        pg_database dat,
        (
                SELECT
                        oid as tbsoid,
                        pg_tablespace_databases(oid) as datoid,
                        spcname 
                FROM 
                        pg_tablespace where spcname='ts_test'
        ) tbs
WHERE
        dat.oid=tbs.datoid
;
 datname | spcname |            spclocation             
---------+---------+------------------------------------
 db_test | ts_test | /var/lib/postgresql/pg_tbs/ts_test
(1 row)

\end{lstlisting}

Moving a tablespace to another physical location it's not complicated; the cluster of course has to 
be shut down; see \ref{sec:SHUTDOWN_SEQ} for more informations about the shutdown sequence.\newline

When the cluster is stopped the container directory can be copied to the new location; the 
directory's access permissions must be the same as the origin; read write for the os user running 
the postgresql process only, otherwise the cluster will refuse to start.\newline

When the copy is complete and the symbolic link in \$PGDATA/pg\_tblspc is fixed to point the new 
location the cluster can be started as shown in \ref{sec:STARTUP}.

\section{MVCC} \label{sec:MVCC}\index{MVCC} 
The multiversion concurrency control is the access method used by PostgreSQL to provide the 
transactional model as seen in \ref{sec:TRANSACTION}.\newline

At logical level this is completely transparent to the user and the new row versions become visible 
after the commit, accordingly with the transaction isolation level. \newline

At physical level we have for each new row version, the insert's XID stamped into the t\_xmin 
field. The PostgreSQL's internal semantic makes visible only the committed rows stamped with the 
XID lesser than the current transaction's XID because considered \textit{in the past}. The rows 
with 
a XID greater than the current transaction's XID are considered \textit{in the future} and then 
invisible.\newline

Because the XID is a 32 bit quantity, it wraps at 4 billions. When this happens theoretically all 
the tuples should suddenly disappear because they switch from in the XID's past to its future. This 
is the XID wraparound failure,\index{XID wraparound failure} a serious problem for the older 
PostgreSQL versions, which only fix was to re init a new data area each 4 billion transactions and 
dump reload the databases.\newline 

PostgreSQL 7.2 introduced the \begin{math}modulo-2^{32}\end{math} arithmetic for evaulating the XID 
age where a special XID, the FrozenXID\footnote{The FrozenXID's value is 2. The docs of PostgreSQL 
7.2 also mention the BootstrapXID with value 1} was assumed as always in the past and having, for 
any given XID 2 billion transactions in the future and 2 billion transactions in the past.\newline

When the age of the stamped t\_xmin becomes old then the VACUUM\index{VACUUM} can freeze 
the tuple stamping the FrozenXID and preserving it from the disappearance. The pg\_class and the 
pg\_database table have a dedicated field to track the oldest tuple inside the relation and the 
database, respectively the relfrozenxid  and the datfrozenxid where the oldest not frozen XID's 
value is stored. The builtin function age() shows how many transactions are between 
the current XID and the value stored in the system catalogue. \newline

For example this is a query to get all the databases with the datfrozenxid and the age.\newpage

\begin{lstlisting}[style=pgsql]
 postgres=# 
        SELECT 
                datname,
                age(datfrozenxid),
                datfrozenxid 
        FROM 
                pg_database;
    datname    | age  | datfrozenxid 
---------------+------+--------------
 template1     | 4211 |          679
 template0     | 4211 |          679
 postgres      | 4211 |          679
 db_test       | 4211 |          679

\end{lstlisting}

The datfroxenxid value is meaningful only through the age function which shows the
``distance'' between the current XID and the datfroxenxid. PostgreSQL assigns the new 
XID only for the write transactions and only if the tuples are updated in the so called ``lazy XID 
assignment''.\newline 


When a tuple's XID becomes older than 2 billion transactions, the tuple simply disappears  jumping 
from the the current XID's past to its future. Before the version 8.0 there was no prevention
for this problem, except the periodic cluster wide VACUUM. The latest versions introduced a 
passive protection mechanism emitting messages in the activity log when the age of datfrozenxid is  
ten million transactions from the wraparound point.

\begin{smallverbatim}
WARNING:  database "test_db" must be vacuumed within 152405486 transactions
HINT:  To avoid a database shutdown, execute a database-wide VACUUM in 
"test_db".
\end{smallverbatim}

Another active protection is the autovacuum daemon which take care of the affected tables and 
starts a VACUUM to freeze the tuples even  if autovacuum is turned off. However if something goes 
wrong and the datfrozenxid reaches one million transactions from the wraparound point, the 
cluster shutdown and keeps shutting down for each transaction. When this happens the cluster 
can be only  started in single-user backend to execute the VACUUM.\newline

To limit the effect of data bloat, unavoidable with this implementation,  PostgreSQL have the 
feature called HOT\index{HOT strategy} which stands for Heap Only Tuples. The RDBMS tries to keep 
the updated tuples inside the same page avoiding also any index reference update, if present. This 
is possible only if there's available free space. By default PostgreSQL when inserting the 
tuples, fills up the pages completely; however is possible to reserve a page portion for the 
updates with the fillfactor storage parameter\index{fillfactor storage parameter}. This is the 
percentage of the page to reserve for the inserts. The default value for the heap pages is 100, 
complete packing. For the indices is 70 for the not leaf pages and 90 for the leaf pages leaving 
some space available for the unavoidable updates. A smaller fill factor will result, at insert time, 
with a bigger table but with lesser grow rate when updated. \newline

Finally if the MVCC is not carefully considered at design time, this can result in data bloat and 
generally poor performances.
In the \ref{cha:MAINTENANCE} we'll see how and how to keep the cluster in efficient conditions or 
at least how to try.