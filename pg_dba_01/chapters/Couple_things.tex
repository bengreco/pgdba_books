\chapter{A couple of things to know before start coding...}
\label{cha:COUPLETHINGS}
This chapter is completely different from the rest of the book. It's dedicated to the developers. 
PostgreSQL is a fantastic infrastructure for building powerful and scalable applications. In order 
to use al its potential there are some things to consider. In particular if coming from other DBMS 
there are subtle caveats that can make the difference between a magnificent success or a miserable 
failure. 

\section{SQL is your friend}
Recently the rise of the NOSQL approach,has shown more than ever how SQL is a fundamental 
requirement for managing the data efficiently. All the shortcuts, like the ORMs or the SQL 
engines implemented over the NOSQL systems, sooner or later will show their limits. Despite the 
bad reputation around it, the SQL language is very simple to understand. 
Purposely built with few simple English words is a powerful tool set for accessing, managing or 
defining the data model. Unfortunately this simplicity have a cost. The language must be parsed and 
converted into the database structure and sometimes there is a misunderstanding between 
what the developer wants and what the database understands.\newline 

Mastering the SQL is a slow and difficult process and requires some sort of empathy with the DBMS. 
Asking for advice to the database administrator is a good idea to get introduced in the the 
database mind. Having a few words with the DBA is a good idea in any case though.

\section{Design comes first}
One of the worst mistakes when building an application is to forget about the foundation, the 
database. With the rise of the ORM\footnote{Yes, I hate the ORMs} this is happening 
more frequently than it could be expected. Sometimes the database itself is considered as 
\textit{storage}, one of the biggest mistake possible.\newline

Forgetting about the database design is like building a skyscraper from the top. If 
unfortunately the project is successful there are good chances to see it crumbling down instead of 
making money.\newline
In particular one of the PostgreSQL's features, the MVCC, is completely ignored at design time. 
In \ref{sec:MVCC} it's explained how is implemented and what are the risks when designing a data 
model. It doesn't matter if the database is simple or the project is small. Nobody knows how 
successful could be a new idea. Having a robust design will make the project to scale properly.

\section{Clean coding}
One of the the first things a developer learns is how to write formatted code. The purpose of 
having clean code is double. It simplifies the code's reading to the other developers and 
improves the code management when, for example, is changed months after the writing. In this good 
practice the SQL seems to be an exception. Is quite common to find long queries written all 
lowercase, on one single line with keywords used as identifier. Trying just to understand what such 
query does is a nightmare. What follow is a list of good practice for writing decent SQL and avoid 
a massive headache to your DBA. If you don't have a DBA see \ref{sec:GETDBA}.

\subsection{The identifier's name}
Any DBMS have its way of managing the identifiers. PostgreSQL transforms the identifier's name in  
lowercase. This doesn't work very well with the camel case, however it's still possible to mix
upper and lower case letters enclosing the identifier name between double quotes. This makes the
code difficult to read and to maintain. Using the underscores in the old fashion way it makes
things simpler.

\subsection{Self explaining schema}
When a database structure becomes complex is very difficult to say what is what and how 
it relates with the other objects. A design diagram or a data dictionary can help. But they can be 
outdated or maybe are not generally accessible. Adopting a simple prefix to add to the relation's
name will give an immediate outlook of the object's kind.\newline

\begin{table}[H]
\begin{tabular}{ll}
 \textbf{Object} & \textbf{Prefix}  \\
 \hline
 Table & t\_ \\
 View & v\_ \\
Btree Index & idx\_bt\_ \\
GiST Index & idx\_gst\_ \\
GIN Index & idx\_gin\_ \\
Unique index & u\_idx\_ \\
Primary key & pk\_ \\
Foreign key & fk\_ \\
Check & chk\_ \\
Unique key & uk\_ \\
Type & ty\_ \\
Sql function & fn\_sql\_ \\
PlPgsql function & fn\_plpg\_ \\
PlPython function & fn\_plpy\_ \\
PlPerl function & fn\_plpr\_ \\
Trigger & trg\_ \\
rule & rul\_ \\

\end{tabular}
\end{table}

A similar approach can be used for the column names, making the data type immediately recognisable.

\begin{table}[H]
\begin{tabular}{ll}
 \textbf{Type} & \textbf{Prefix}  \\
 \hline
 Character & c\_ \\
 Character varying & v\_ \\
Integer & i\_ \\
Text & t\_ \\
Bytea & by\_ \\
Numeric & n\_ \\
Timestamp & ts\_ \\
Date & d\_ \\
Double precision & dp\_ \\
Hstore & hs\_ \\
Custom data type & ty\_ \\

\end{tabular}
\end{table}



\subsection{Query formatting}
Having a properly formatted query helps to understand which objects are involved in the data
retrieval and the relations between them. Even with a very simple query a careless writing can make
it very difficult to understand.


\begin{lstlisting}[style=pgsql]
select * from debitnoteshead a join debitnoteslines b on debnotid 
where a.datnot=b. datnot and b.deblin>1;
\end{lstlisting}

A query like this have many issues .\newline

\begin{itemize}
 \item using lowercase keywords it makes difficult to spot them
\item the wildcard * hides which columns are effectively needed; it retrieves all the columns
consuming more bandwidth than required; it prevents the index only scans
\item the meaningless aliases like \textit{a} and \textit{b} it make difficult to understand which
relations are involved.
\item writing a statement with no indenting it makes difficult to understand the query's
logic.
\end{itemize}

Despite existence of tools capable to prettify such queries, their usage doesn't solve the
root problem. It's better to write immediately decent SQL following those simple rules.

\begin{itemize}
 \item All SQL keywords should be in upper case
 \item All the identifiers and kewrords should be grouped by line break and indented at the same
level
 \item In the SELECT list specify all and only the columns required by the query
 \item Avoid the auto join in order to make clear the relation's logic
 \item Adopt meaningful aliases
\end{itemize}

And that's the fixed SQL.

\begin{lstlisting}[style=pgsql]
SELECT
        productcode,
        noteid,
        datnot
FROM
        debitnoteshead head
        INNER JOIN
                debitnoteslines lines
                ON
                                head.debnotid=lines.debnotid
                        AND     head.datnot=lines.datnot
WHERE
               lines.deblin>1
;
\end{lstlisting}


\section{Get DBA advice}
\label{sec:GETDBA}
The database administration is weird. It's very difficult to explain what a DBA does. It's a job
where the statement ``failure is not an option" is the rule number zero. A DBA usually works in
antisocial hours, with a very limited time window. A DBA holds a lot on the shoulders and that's
the reason why those people can seem hostile or living in their own world.\newline

Despite the strange reputation, a database expert is an incredible resource for building up
efficient and scalable designs. Nowadays is very simple to set up a PostgreSQL instance. Even with
the default configuration parameter the system is so efficient that basically doesn't show any
problem when running at low or medium load. If this, at first sight, seems a fantastic feature
actually is a really bad thing. Any mistake at design level is hidden and when the problem sooner or
later appears is too late.\newline

This final advice is probably the most important of the entire chapter. If you have a DBA don't be
shy. Ask for any suggestion, even if the solution seems obvious or if the task is small. The
database layer is a completely different universe. A small mistake can result in a
very big problem.\newline

Of course if there's no DBA, that's bad. Never sail without a compass. Never start a database
project without an expert. A professional to take care of the most important part, the
foundations.\newline

If this is the case, ask your employer to hire a PostgreSQL DBA as soon as possible.