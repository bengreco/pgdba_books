\chapter{The cluster in action}
PostgreSQL delivers the data ensuring the ACID is enforced at any time. In order to understand how 
this is possible we'll take look to a ``day in the life'' of a PostgreSQL's cluster. The chapter 
is purposely skipping the technical details focusing on the global picture.


\section{After the startup}
When the cluster completes the startup procedure the connections are allowed immediately. When a 
client's connection is authorised the postgres main process forks into a new backend process which is 
assigned to the connection for the client's lifetime. This process is quite expensive and does not work 
very well for an high rate of connection's requests. The maximum number of connection is set at startup and 
cannot be changed dynamically. Whether the connection is used or not ~400 bytes of shared memory are 
consumed for each connection slot.\newline

If there's no backend connected the cluster is not lazy. 

\section{The write ahead log}
The data pages are cached into the shared buffer for read or write. A mechanism called pinning ensures that 
only one backend at time is accessing the page in memory. If the page is modified becomes dirty, which 
means the page is not yet written on the data file. The change is saved on the write ahead log as WAL
record. The commit status for the transactions is saved in the directory clog or pg\_serial. This 
is all the cluster needs to rebuild his last consistent state before a crash. 

\section{The checkpoint}

\section{The background writer}


\section{Transactions}

\section{The backends}

